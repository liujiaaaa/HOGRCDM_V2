# registerDoParallel(cl)
#
Beta<-rbind(Interc_B,t(Slope_B) )
passing=0
while((passing<Passing & i<maxIter)){
if((PRINT&i%%PR_ITER_NUM==0)){
print(Slope_B)###This can be revised to print more information
print( Slope_H)
print( Interc_H)
print(Sigma_theta)
print(ta)
}
Pre_LAMBDA<-LAMBDA
Pre_Sigma_theta<-Sigma_theta
Pre_Beta<-  Beta
AS<-t(Slope_H)%*%Sigma_theta%*%Slope_H
SdAS<-sqrt(1+diag(AS))
SdASM[,]<-I1L%*%t(SdAS)
TsAS<-SdAS%*%t(SdAS)
# TsASA[,,]<-TsAS
AT<-AS/TsAS
diag( AT)<-1 #cor of diagonal equal to 1
ST[,,]<- AT
#SA is covariance matrix
SA<-IA2*ST
#TsASA[,,]<-TsAS
# ASA[,,]<-AS
# SA<-(ASA*IA2)/TsASA
#for(l in 1:L){
#  diag(SA[,,l])<-1
#}
IAd<-IA*(I1L%*%t(Interc_H))
Fq<-IAd/SdASM
# for(l in 1:L){
#   PA[l]<- mvtnorm::pmvnorm(lower=LOW,upper=Fq[l,],mean=MEAN,corr=SA[,,l])
# }
PA<-apply(matrix(1:L),1,FUN=PACDF,LOW=LOW,upperMat=Fq,corrArr=SA)
###################################################
if(i<NumOfWeight)  PA<-PA*1/2+rep(1/L,L)*1/2
###################################################
#  PA <- foreach(l = 1:L, .combine = "c") %dopar% {
#   library(mvtnorm)
#   pmvnorm(lower = LOW, upper = Fq[l,], mean = MEAN, corr = SA[,,l])
# }
PAM[,]<-PA%*%t(I1N)
Interc_B_matrix[,]<-I1L%*%t(Interc_B)
t_Beta1_Mat<-t(Slope_B)
AB<-Poss_AttrUp%*%t_Beta1_Mat+Interc_B_matrix
#########################
AB[AB<0]<- 0.05
##########################
PRT1[,]<-dpois(as.vector(ResM),as.vector(AB[rLN,]))
PRTNJL[,]<-rowProds(PRT1)
PRTNJ<-t(PRTNJL)
NUM<-PRTNJ*PAM
DEM<-colSums(NUM)
DEMM<-rep(1,L)%*%t(DEM)
#Posterior
PRAA<-NUM/DEMM
#default family is gaussian
ppA<-(rowSums(PRAA))
PRAV<-sqrt(ppA)
PRAVM<-PRAV%*%t(rep(1,D))
WEI<-as.vector(PRAA)
PRAV_s<-as.vector(t(PRAA))%*%t(rep(1,J))
Beta<-sapply(1:J, OptBott_Confir, x=Data_x,
Res=Data_Res,Q_mat=Q_Aug,weights=WEI,Family="poisson", Link="identity",
simplify = T)
Interc_B <- Beta[1,]
Slope_B <- t(Beta[-1,])
colnames(Interc_B)<-NULL
rownames(Slope_B)<-colnames( Slope_B)<-NULL
thetas1<- sample_thetas(L,K,D,data=Poss_Attr,Slope_H,Interc_H,
Sigma_theta=Sigma_theta,mc_samples=IncreSize)
thetaA<-array(NA,dim=c(L,IncreSize,D))
for(ll in 1:L){
# print((((ll-1)*mc_samples)+1):(ll*mc_samples))
thetaA[ll,,]<-thetas1[(((ll-1)*IncreSize)+1):(ll*IncreSize),]
}
thetaA1<-aperm( thetaA,c(3,2,1))
theta_At<-matrix(NA,D,L*IncreSize)
theta_At[,]<-thetaA1
thetaD<-t(theta_At[,])
xxD<-Poss_Attr[rep(1:L,each=IncreSize),]
wwe<-rep(ppA,each=IncreSize)
wee1<- rep(PRAV,each=IncreSize)
thetas2<- thetas1*(wee1%*%t(rep(1,D)))
# LAMBDA<-sapply(1:K,  Opt_Weight_Higher,Q_mat=Q_H,
#                x=thetaD,
#                Res=xxD,weights= wwe, Link="probit",
#                LLambda=rep(0,K), simplify = T)
LAMBDA<-sapply(1:K,    Opt_Weight_Higher_Simpler,Q_mat=Q_H,
x=thetaD,
Res=xxD,weights= wwe, Link="probit",
simplify = T)
#print(test)
# result_Lamnda<-rbind(LAMBDA[-1,],LAMBDA[1,])
#  Lambda[t(QQc)!=0]<-result_Lamnda
#  print( Lambda)
Slope_H<-LAMBDA[-1,]
Interc_H<-LAMBDA[1,]
# Sigma_theta<-(theta_At)%*%t(theta_At)/(L*IncreSize)
Sigma_theta<-t(thetas2)%*%thetas2/(IncreSize*N)
if(isBifactor){
Sigma_theta1<-Sigma_theta[-1,-1]
D1<-D-1
Zrs<-tanh(Sigma_theta1)
diag(Zrs)<-0
Zrs[lower.tri(Zrs)]<-0
UU<-matrix(NA,D1,D1)
UU[lower.tri(UU)]<-0
UU[1,1]<-1
UU[1,-1]<-Zrs[1,-1]
for(r in 2:D1){
for(s in r:D1){
if(r==s){
UU[r,s]<-prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
} else{
UU[r,s]<- Zrs[r,s]* prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
}
}
}
Sigma_theta[-1,-1]<-t(UU)%*%UU
Sigma_theta[1,-1]<-0
Sigma_theta[-1,1]<-0
Sigma_theta[1,1]<-1
# Sigma_theta[-1,-1]<-cov2cor(Sigma_theta[-1,-1])
# Sigma_theta[1,-1]<-0
# Sigma_theta[-1,1]<-0
# Sigma_theta[1,1]<-1
}else
{
#################STAN 1
Sigma_theta1<-Sigma_theta
D1<-D
Zrs<-tanh(Sigma_theta1)
diag(Zrs)<-0
Zrs[lower.tri(Zrs)]<-0
UU<-matrix(NA,D1,D1)
UU[lower.tri(UU)]<-0
UU[1,1]<-1
UU[1,-1]<-Zrs[1,-1]
for(r in 2:D1){
for(s in r:D1){
if(r==s){
UU[r,s]<-prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
} else{
UU[r,s]<- Zrs[r,s]* prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
}
}
}
Sigma_theta<-t(UU)%*%UU
# Sigma_theta<-cov2cor(Sigma_theta)
}
# Interc_H<- Interc_HT
#Slope_H[,1:D]<-Slope_HT[,1:D]
eps<-max(abs( Pre_Sigma_theta- Sigma_theta),abs( Pre_LAMBDA-LAMBDA),
abs( Pre_Beta- Beta))
if(eps<epsCheck) passing=passing+1
# Interc_H[1]<-Interc_HT[1]
i<-i+1
IncreSize=IncreSize+5
}
print(Slope_B)###This can be revised to print more information
while((passing<Passing & i<maxIter)){
if((PRINT&i%%PR_ITER_NUM==0)){
print(Slope_B)###This can be revised to print more information
print( Slope_H)
print( Interc_H)
print(Sigma_theta)
print(ta)
}
print(Slope_B)###This can be revised to print more information
print( Slope_H)
print( Interc_H)
print(Sigma_theta)
print(ta)
Pre_LAMBDA<-LAMBDA
Pre_Sigma_theta<-Sigma_theta
Pre_Beta<-  Beta
AS<-t(Slope_H)%*%Sigma_theta%*%Slope_H
SdAS<-sqrt(1+diag(AS))
SdASM[,]<-I1L%*%t(SdAS)
TsAS<-SdAS%*%t(SdAS)
# TsASA[,,]<-TsAS
AT<-AS/TsAS
diag( AT)<-1 #cor of diagonal equal to 1
ST[,,]<- AT
#SA is covariance matrix
SA<-IA2*ST
#TsASA[,,]<-TsAS
# ASA[,,]<-AS
# SA<-(ASA*IA2)/TsASA
#for(l in 1:L){
#  diag(SA[,,l])<-1
#}
IAd<-IA*(I1L%*%t(Interc_H))
Fq<-IAd/SdASM
# for(l in 1:L){
#   PA[l]<- mvtnorm::pmvnorm(lower=LOW,upper=Fq[l,],mean=MEAN,corr=SA[,,l])
# }
PA<-apply(matrix(1:L),1,FUN=PACDF,LOW=LOW,upperMat=Fq,corrArr=SA)
###################################################
if(i<NumOfWeight)  PA<-PA*1/2+rep(1/L,L)*1/2
###################################################
#  PA <- foreach(l = 1:L, .combine = "c") %dopar% {
#   library(mvtnorm)
#   pmvnorm(lower = LOW, upper = Fq[l,], mean = MEAN, corr = SA[,,l])
# }
PAM[,]<-PA%*%t(I1N)
Interc_B_matrix[,]<-I1L%*%t(Interc_B)
t_Beta1_Mat<-t(Slope_B)
AB<-Poss_AttrUp%*%t_Beta1_Mat+Interc_B_matrix
#########################
AB[AB<0]<- 0.05
##########################
PRT1[,]<-dpois(as.vector(ResM),as.vector(AB[rLN,]))
PRTNJL[,]<-rowProds(PRT1)
PRTNJ<-t(PRTNJL)
NUM<-PRTNJ*PAM
DEM<-colSums(NUM)
DEMM<-rep(1,L)%*%t(DEM)
#Posterior
PRAA<-NUM/DEMM
#default family is gaussian
ppA<-(rowSums(PRAA))
PRAV<-sqrt(ppA)
PRAVM<-PRAV%*%t(rep(1,D))
WEI<-as.vector(PRAA)
PRAV_s<-as.vector(t(PRAA))%*%t(rep(1,J))
Beta<-sapply(1:J, OptBott_Confir, x=Data_x,
Res=Data_Res,Q_mat=Q_Aug,weights=WEI,Family="poisson", Link="identity",
simplify = T)
Interc_B <- Beta[1,]
Slope_B <- t(Beta[-1,])
colnames(Interc_B)<-NULL
rownames(Slope_B)<-colnames( Slope_B)<-NULL
thetas1<- sample_thetas(L,K,D,data=Poss_Attr,Slope_H,Interc_H,
Sigma_theta=Sigma_theta,mc_samples=IncreSize)
thetaA<-array(NA,dim=c(L,IncreSize,D))
for(ll in 1:L){
# print((((ll-1)*mc_samples)+1):(ll*mc_samples))
thetaA[ll,,]<-thetas1[(((ll-1)*IncreSize)+1):(ll*IncreSize),]
}
thetaA1<-aperm( thetaA,c(3,2,1))
theta_At<-matrix(NA,D,L*IncreSize)
theta_At[,]<-thetaA1
thetaD<-t(theta_At[,])
xxD<-Poss_Attr[rep(1:L,each=IncreSize),]
wwe<-rep(ppA,each=IncreSize)
wee1<- rep(PRAV,each=IncreSize)
thetas2<- thetas1*(wee1%*%t(rep(1,D)))
# LAMBDA<-sapply(1:K,  Opt_Weight_Higher,Q_mat=Q_H,
#                x=thetaD,
#                Res=xxD,weights= wwe, Link="probit",
#                LLambda=rep(0,K), simplify = T)
LAMBDA<-sapply(1:K,    Opt_Weight_Higher_Simpler,Q_mat=Q_H,
x=thetaD,
Res=xxD,weights= wwe, Link="probit",
simplify = T)
#print(test)
# result_Lamnda<-rbind(LAMBDA[-1,],LAMBDA[1,])
#  Lambda[t(QQc)!=0]<-result_Lamnda
#  print( Lambda)
Slope_H<-LAMBDA[-1,]
Interc_H<-LAMBDA[1,]
# Sigma_theta<-(theta_At)%*%t(theta_At)/(L*IncreSize)
Sigma_theta<-t(thetas2)%*%thetas2/(IncreSize*N)
if(isBifactor){
Sigma_theta1<-Sigma_theta[-1,-1]
D1<-D-1
Zrs<-tanh(Sigma_theta1)
diag(Zrs)<-0
Zrs[lower.tri(Zrs)]<-0
UU<-matrix(NA,D1,D1)
UU[lower.tri(UU)]<-0
UU[1,1]<-1
UU[1,-1]<-Zrs[1,-1]
for(r in 2:D1){
for(s in r:D1){
if(r==s){
UU[r,s]<-prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
} else{
UU[r,s]<- Zrs[r,s]* prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
}
}
}
Sigma_theta[-1,-1]<-t(UU)%*%UU
Sigma_theta[1,-1]<-0
Sigma_theta[-1,1]<-0
Sigma_theta[1,1]<-1
# Sigma_theta[-1,-1]<-cov2cor(Sigma_theta[-1,-1])
# Sigma_theta[1,-1]<-0
# Sigma_theta[-1,1]<-0
# Sigma_theta[1,1]<-1
}else
{
#################STAN 1
Sigma_theta1<-Sigma_theta
D1<-D
Zrs<-tanh(Sigma_theta1)
diag(Zrs)<-0
Zrs[lower.tri(Zrs)]<-0
UU<-matrix(NA,D1,D1)
UU[lower.tri(UU)]<-0
UU[1,1]<-1
UU[1,-1]<-Zrs[1,-1]
for(r in 2:D1){
for(s in r:D1){
if(r==s){
UU[r,s]<-prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
} else{
UU[r,s]<- Zrs[r,s]* prod((1-Zrs[(1:(r-1)),s]^2)^(1/2))
}
}
}
Sigma_theta<-t(UU)%*%UU
# Sigma_theta<-cov2cor(Sigma_theta)
}
# Interc_H<- Interc_HT
#Slope_H[,1:D]<-Slope_HT[,1:D]
eps<-max(abs( Pre_Sigma_theta- Sigma_theta),abs( Pre_LAMBDA-LAMBDA),
abs( Pre_Beta- Beta))
if(eps<epsCheck) passing=passing+1
# Interc_H[1]<-Interc_HT[1]
i<-i+1
IncreSize=IncreSize+5
}
source("C:/Users/Liujia/Desktop/HOGRCDM_V2/R/FIT_CC_Poisson.R")
source("C:/Users/Liujia/Desktop/HOGRCDM_V2/R/FIT_CC_Poisson.R")
source("C:/Users/Liujia/Desktop/HOGRCDM_V2/R/FIT_CC_LLM.R")
source("C:/Users/Liujia/Desktop/HOGRCDM_V2/R/FIT_CC_Lognormal.R")
source_all <- function(directory = "R") {
# Get a list of all R files in the specified directory
files <- list.files(directory, pattern = "\\.R$", full.names = TRUE)
# Source each file
for (file in files) {
source(file)
}
}
# Example usage
source_all("R")
ModelSetList<-list(
ModelDistri_Bottom="Poisson",
ModelStruc_Bottom="Main_effect",
ModelStruc_Higher="Subscale",
ModelFrame_Bottom="Confirmatory",
ModelFrame_Higher="Confirmatory"
)
# ModelDistri_Bottom=ModelSet$ModelDistri_Bottom,
# ModelStruc_Bottom=ModelSet$ModelStruc_Bottom,
# ModelStruc_Higher=ModelSet$ModelStruc_Higher,
# ModelFrame_Bottom=ModelSet$ModelFrame_Bottom,
# ModelFrame_Higher=ModelSet$ModelFrame_Higher
LoadingPackages()
ModelSet<-
ModelSetCheck(ModelSetList)
ModelSetList<-list(
ModelDistri_Bottom=ModelSet$ModelDistri_Bottom,
ModelStruc_Bottom=ModelSet$ModelStruc_Bottom,
ModelStruc_Higher=ModelSet$ModelStruc_Higher,
ModelFrame_Bottom=ModelSet$ModelFrame_Bottom,
ModelFrame_Higher=ModelSet$ModelFrame_Higher
)
SizeList<-list(
N=2000,
J=30,
K=7,
D=3
)
N<-SizeList$N
J<-SizeList$J
K<-SizeList$K
D<-SizeList$D
L<-2^K
######Loading Q matrices and True Parameters for Higher Order Structures: Slope_H and Interc_H
load("./LoadValue/QGU.RData")
if(ModelSetList$ModelStruc_Higher=="Subscale"){
load("./LoadValue/Simple1.RData")
}else if(ModelSetList$ModelStruc_Higher=="Bifactor"){
load("./LoadValue/BIFACTOR1.RData")
}
Q_B<-Q
Q_H<-t(Lam_1T)
Q_H[Q_H!=0]<-1
Slope_H<-Lam_1T
Interc_H<-Lam_0T
Sigma_thetaT<-diag(D)
Sigma_thetaT[2,3]<-Sigma_thetaT[3,2]<-0.35
TrueP_List_High<-list(
Slope_H=Slope_H,
Interc_H=Interc_H,
Mu_thetaT=rep(0,D),
Sigma_thetaT=Sigma_thetaT
)
##############This is only a procedure for my simulation
##############Users can input their own true parameters
if(ModelSetList$ModelStruc_Bottom=="Main_effect"){
Beta1_MatT<-matrix(Q,J,K)
Beta0T<-rep(NA,J)
Beta_Para_List<-list()
for(j in 1:J){
Beta_Para_List[[j]]<-c(0.5, rep((1)/(rowSums(Q)[j]),rowSums(Q)[j]))
Beta1_MatT[j,][Beta1_MatT[j,]==1]<- Beta_Para_List[[j]][-1]
Beta0T[j]<-Beta_Para_List[[j]][1]
#print(sum(Beta_Para_List[[j]]-c(Beta0T[j],Beta1_MatT[j,][Beta1_MatT[j,]!=0])))
}
Slope_B<-Beta1_MatT
Interc_B<-Beta0T
}else if(ModelSetList$ModelStruc_Bottom=="All_effect"){
Q_Aug<-Q_B
q_num1<-K
for(kk in 2:K){
combinations <- t(combn(1:K, kk))
te<-apply( Q_B,1,FUN= comFUN, combinations)
# print(dim(as.matrix(te)))
# print(choose(K1,kk))
if(kk<K) te<-t(te)
Q_Aug<-cbind(Q_Aug,te)
q_num1<-q_num1+choose(K,kk)
}
# Beta0T<-rep(NA,J)
SizeList$Q_Aug<-Q_Aug
Beta1_MatT<-Q_Aug
for( rr in 1:nrow( Beta1_MatT)){
Beta1_MatT[rr,][ Beta1_MatT[rr,]!=0]<-1/(2^(sum(  Beta1_MatT[rr,(1:K)]))-1)
# print(B_Slope1T[rr,][B_Slope1T[rr,]!=0])
}
Beta0T<-rep(0.5,J)
Slope_B<-Beta1_MatT
Interc_B<-Beta0T
#
}else if(ModelSetList$ModelStruc_Bottom=="DINA"){
DINA_INDEX<-rep(1,J)
Q_Aug<-Q
q_num1<-K
for(kk in 2:K){
combinations <- t(combn(1:K, kk))
te<-apply( Q,1,FUN= comFUN, combinations)
# print(dim(as.matrix(te)))
# print(choose(K1,kk))
if(kk<K){
te<-t(te)
DINA_INDEX<-  (1-as.numeric(rowSums(te)>0))*DINA_INDEX+kk*as.numeric(rowSums(te)>0)
}else if(kk==K){
DINA_INDEX<-  (1-as.numeric((te)>0))*DINA_INDEX+kk*as.numeric((te)>0)
}
indd<-which(DINA_INDEX==kk)
if(length(indd)>0)  Q_Aug[indd,]<-0
Q_Aug<-cbind(Q_Aug,te)
q_num1<-q_num1+choose(K,kk)
}
# Beta0T<-rep(NA,J)
SizeList$Q_Aug<-Q_Aug
Beta1_MatT<-Q_Aug
for( rr in 1:nrow( Beta1_MatT)){
Beta1_MatT[rr,][ Beta1_MatT[rr,]!=0]<-1
# print(B_Slope1T[rr,][B_Slope1T[rr,]!=0])
}
Beta0T<-rep(0.5,J)
Slope_B<-Beta1_MatT
Interc_B<-Beta0T
}
TrueP_List_Bott<-list(
Slope_B=Slope_B,
Interc_B=Interc_B,
sd=rep(1,J),
Q_Aug=Q_Aug
)
####################This list is used for simulation with exploratory case where
####################Hungarian algorithm is applied for computing Q_B matrix recovery
Com_par<-list(
Slope_B=TrueP_List_Bott$Slope_B,
Interc_B=TrueP_List_Bott$Interc_B,
SD=TrueP_List_Bott$sd,
Slope_H=TrueP_List_High$Slope_H,
Interc_H=TrueP_List_High$Interc_H,
Mu_thetaT=TrueP_List_High$Mu_thetaT,
Sigma_thetaT=TrueP_List_High$Sigma_thetaT
)
Res<-GenerateData(SizeList,ModelSetList,TrueP_List_Bott,TrueP_List_High,Q_B)
###Find initial values
InitAll<-INIT_HOGRCDM_Main(ModelSetList,SizeList,Res,Q_B,Q_H)
InitAll
SettingList<-list(
StartSamSize=5,
IncreSize=5,
NumOfWeight=5,
maxIter=100,
ReturnLikelihood=T,
epsCheck=0.04,
Passing=3,
PRINT=T,
PR_ITER_NUM=5
)
FIT= FIT_HOGRCDM_Main(ModelSetList,SizeList,Res,Q_H,PenaltyList)
FIT$Slope_B
FIT$
FIT
install.packages("C:/Users/Liujia/Desktop/SCFA.zip", repos = NULL, type = "win.binary")
install.packages("C:/Users/Liujia/Desktop/SCFA-main.zip", repos = NULL, type = "win.binary")
library(SCFA-main)
library(SCFA)
installed_packages <- installed.packages()
print(installed_packages[, "Package"])
installed_packages <- installed.packages()
which(installed_packages=="SCFA")
install.packages("C:/Users/Liujia/Desktop/SCFA-main.zip", repos = NULL, type = "win.binary")
library(SCFA)
library(SCFA)
installed_packages <- installed.packages()
which(installed_packages=="SCFA")
